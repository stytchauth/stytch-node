/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Stytch
 * This is the Stytch api.  You can find out more about Stytch at  [stytch.com](https://stytch.com). 
 *
 * OpenAPI spec version: v1
 * Contact: hello@stytch.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://test.stytch.com/v1";
const LIVE_PATH = "https://api.stytch.com/v1";

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = portableFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.environment == 'LIVE' ? LIVE_PATH : BASE_PATH;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Attributes
 */
export interface Attributes {
    /**
     * The ip address of the user.
     * @type {string}
     * @memberof Attributes
     */
    ipAddress?: string;
    /**
     * The user agent of the user.
     * @type {string}
     * @memberof Attributes
     */
    userAgent?: string;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * The HTTP Status such as OK, Canceled, Aborted etc.
     * @type {number}
     * @memberof ErrorResponse
     */
    status?: number;
    /**
     * A unique identified for the request.
     * @type {string}
     * @memberof ErrorResponse
     */
    requestId?: string;
    /**
     * The type of error such as user_not_found, invalid_parameters, etc that specifically describes the reason the error occurred.
     * @type {string}
     * @memberof ErrorResponse
     */
    errorType?: string;
    /**
     * A human readable description of the error with details on debugging.
     * @type {string}
     * @memberof ErrorResponse
     */
    errorMessage?: string;
    /**
     * Url for where in the docs to find more information about this error.
     * @type {string}
     * @memberof ErrorResponse
     */
    errorUrl?: string;
}
/**
 * 
 * @export
 * @interface MagicLinkAuthenticate
 */
export interface MagicLinkAuthenticate {
    /**
     * 
     * @type {MagicLinkAuthenticateOptions}
     * @memberof MagicLinkAuthenticate
     */
    options?: MagicLinkAuthenticateOptions;
    /**
     * 
     * @type {Attributes}
     * @memberof MagicLinkAuthenticate
     */
    attributes?: Attributes;
}
/**
 * 
 * @export
 * @interface MagicLinkAuthenticateOptions
 */
export interface MagicLinkAuthenticateOptions {
    /**
     * Require that the ip address the magic link was requested from matches the ip address it's clicked from.
     * @type {boolean}
     * @memberof MagicLinkAuthenticateOptions
     */
    ipMatchRequired?: boolean;
    /**
     * Require that the user agent the magic link was requested from matches the user agent it's clicked from.
     * @type {boolean}
     * @memberof MagicLinkAuthenticateOptions
     */
    userAgentMatchRequired?: boolean;
}
/**
 * 
 * @export
 * @interface MagicLinkAuthenticateResponse
 */
export interface MagicLinkAuthenticateResponse {
    /**
     * 
     * @type {string}
     * @memberof MagicLinkAuthenticateResponse
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLinkAuthenticateResponse
     */
    userId?: string;
}
/**
 * 
 * @export
 * @interface MagicLinkInviteByEmail
 */
export interface MagicLinkInviteByEmail {
    /**
     * The email to invite the user by.
     * @type {string}
     * @memberof MagicLinkInviteByEmail
     */
    email: string;
    /**
     * The url the user clicks from the email magic link. This should be a url that your app receives and parses. Then you'll send a to authenticate the magic link and log in the user.
     * @type {string}
     * @memberof MagicLinkInviteByEmail
     */
    magicLinkUrl: string;
    /**
     * Set the expiration for the email magic link, in minutes. By default, it expires in 1 week. The minimum expiration is 5 minutes and the maximum is 7 days (10080 mins).
     * @type {number}
     * @memberof MagicLinkInviteByEmail
     */
    expirationMinutes?: number;
    /**
     * 
     * @type {Attributes}
     * @memberof MagicLinkInviteByEmail
     */
    attributes?: Attributes;
}
/**
 * 
 * @export
 * @interface MagicLinkInviteByEmailResponse
 */
export interface MagicLinkInviteByEmailResponse {
    /**
     * 
     * @type {string}
     * @memberof MagicLinkInviteByEmailResponse
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLinkInviteByEmailResponse
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLinkInviteByEmailResponse
     */
    emailId?: string;
}
/**
 * 
 * @export
 * @interface MagicLinkLoginOrCreate
 */
export interface MagicLinkLoginOrCreate {
    /**
     * The email the user enters to login or sign up with.
     * @type {string}
     * @memberof MagicLinkLoginOrCreate
     */
    email: string;
    /**
     * The url the user clicks from the login email magic link. This should be a url that your app receives and parses and subsequently send an api request to authenticate the magic link and log in the user.
     * @type {string}
     * @memberof MagicLinkLoginOrCreate
     */
    loginMagicLinkUrl: string;
    /**
     * The url the user clicks from the sign up email magic link. This should be a url that your app receives and parses and subsequently send an api request to authenticate the magic link and sign up the user.
     * @type {string}
     * @memberof MagicLinkLoginOrCreate
     */
    signupMagicLinkUrl: string;
    /**
     * Set the expiration for the login email magic link, in minutes. By default, it expires in 1 hour. The minimum expiration is 5 minutes and the maximum is 7 days (10080 mins).
     * @type {number}
     * @memberof MagicLinkLoginOrCreate
     */
    loginExpirationMinutes?: number;
    /**
     * Set the expiration for the sign up email magic link, in minutes. By default, it expires in 1 week. The minimum expiration is 5 minutes and the maximum is 7 days (10080 mins).
     * @type {number}
     * @memberof MagicLinkLoginOrCreate
     */
    signupExpirationMinutes?: number;
    /**
     * 
     * @type {Attributes}
     * @memberof MagicLinkLoginOrCreate
     */
    attributes?: Attributes;
}
/**
 * 
 * @export
 * @interface MagicLinkLoginOrCreateResponse
 */
export interface MagicLinkLoginOrCreateResponse {
    /**
     * 
     * @type {string}
     * @memberof MagicLinkLoginOrCreateResponse
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLinkLoginOrCreateResponse
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLinkLoginOrCreateResponse
     */
    emailId?: string;
    /**
     * Returns true if a new user was created, otherwise returns false
     * @type {boolean}
     * @memberof MagicLinkLoginOrCreateResponse
     */
    userCreated?: boolean;
}
/**
 * 
 * @export
 * @interface MagicLinkLoginOrInvite
 */
export interface MagicLinkLoginOrInvite {
    /**
     * The email to login or invite the user with.
     * @type {string}
     * @memberof MagicLinkLoginOrInvite
     */
    email: string;
    /**
     * The url the user clicks from the login email magic link. This should be a url that your app receives and parses and subsequently send an api request to authenticate the magic link and log in the user.
     * @type {string}
     * @memberof MagicLinkLoginOrInvite
     */
    loginMagicLinkUrl: string;
    /**
     * The url the user clicks from the invite email magic link. This should be a url that your app receives and parses and subsequently send an api request to authenticate the magic link and finish creating the user.
     * @type {string}
     * @memberof MagicLinkLoginOrInvite
     */
    inviteMagicLinkUrl: string;
    /**
     * Set the expiration for the login email magic link, in minutes. By default, it expires in 1 hour. The minimum expiration is 5 minutes and the maximum is 7 days (10080 mins).
     * @type {number}
     * @memberof MagicLinkLoginOrInvite
     */
    loginExpirationMinutes?: number;
    /**
     * Set the expiration for the invite email magic link, in minutes. By default, it expires in 1 week. The minimum expiration is 5 minutes and the maximum is 7 days (10080 mins).
     * @type {number}
     * @memberof MagicLinkLoginOrInvite
     */
    inviteExpirationMinutes?: number;
    /**
     * 
     * @type {Attributes}
     * @memberof MagicLinkLoginOrInvite
     */
    attributes?: Attributes;
}
/**
 * 
 * @export
 * @interface MagicLinkLoginOrInviteResponse
 */
export interface MagicLinkLoginOrInviteResponse {
    /**
     * 
     * @type {string}
     * @memberof MagicLinkLoginOrInviteResponse
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLinkLoginOrInviteResponse
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLinkLoginOrInviteResponse
     */
    emailId?: string;
    /**
     * Returns true if a new user was created, otherwise returns false
     * @type {boolean}
     * @memberof MagicLinkLoginOrInviteResponse
     */
    userCreated?: boolean;
}
/**
 * 
 * @export
 * @interface MagicLinkRevokeInviteByEmail
 */
export interface MagicLinkRevokeInviteByEmail {
    /**
     * The email to invite the user by.
     * @type {string}
     * @memberof MagicLinkRevokeInviteByEmail
     */
    email: string;
}
/**
 * 
 * @export
 * @interface MagicLinkRevokeInviteByEmailResponse
 */
export interface MagicLinkRevokeInviteByEmailResponse {
    /**
     * 
     * @type {string}
     * @memberof MagicLinkRevokeInviteByEmailResponse
     */
    requestId?: string;
}
/**
 * 
 * @export
 * @interface MagicLinkSend
 */
export interface MagicLinkSend {
    /**
     * 
     * @type {string}
     * @memberof MagicLinkSend
     */
    userId: string;
    /**
     * The method id for where to send the magic link, such as an email_id.
     * @type {string}
     * @memberof MagicLinkSend
     */
    methodId: string;
    /**
     * The url the user clicks from the email magic link. This should be a url that your app receives and parses and subsequently send an api request to authenticate the magic link and log in the user.
     * @type {string}
     * @memberof MagicLinkSend
     */
    magicLinkUrl: string;
    /**
     * Set the expiration for the email magic link, in minutes. By default, it expires in 1 hour. The minimum expiration is 5 minutes and the maximum is 7 days (10080 mins).
     * @type {number}
     * @memberof MagicLinkSend
     */
    expirationMinutes: number;
    /**
     * 
     * @type {Attributes}
     * @memberof MagicLinkSend
     */
    attributes?: Attributes;
}
/**
 * 
 * @export
 * @interface MagicLinkSendByEmail
 */
export interface MagicLinkSendByEmail {
    /**
     * The email the user enters to sign in with.
     * @type {string}
     * @memberof MagicLinkSendByEmail
     */
    email: string;
    /**
     * The url the user clicks from the email magic link. This should be a url that your app receives and parses and subsequently send an api request to authenticate the magic link and log in the user.
     * @type {string}
     * @memberof MagicLinkSendByEmail
     */
    magicLinkUrl: string;
    /**
     * Set the expiration for the email magic link, in minutes. By default, it expires in 1 hour. The minimum expiration is 5 minutes and the maximum is 7 days (10080 mins).
     * @type {number}
     * @memberof MagicLinkSendByEmail
     */
    expirationMinutes: number;
    /**
     * 
     * @type {Attributes}
     * @memberof MagicLinkSendByEmail
     */
    attributes?: Attributes;
}
/**
 * 
 * @export
 * @interface MagicLinkSendByEmailResponse
 */
export interface MagicLinkSendByEmailResponse {
    /**
     * 
     * @type {string}
     * @memberof MagicLinkSendByEmailResponse
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLinkSendByEmailResponse
     */
    userId?: string;
}
/**
 * 
 * @export
 * @interface MagicLinkSendResponse
 */
export interface MagicLinkSendResponse {
    /**
     * 
     * @type {string}
     * @memberof MagicLinkSendResponse
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof MagicLinkSendResponse
     */
    userId?: string;
}
/**
 * 
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * The email to use for email magic links. This can be changed later via the update endpoint.
     * @type {string}
     * @memberof UserCreate
     */
    email: string;
    /**
     * 
     * @type {UserCreateName}
     * @memberof UserCreate
     */
    name?: UserCreateName;
    /**
     * 
     * @type {Attributes}
     * @memberof UserCreate
     */
    attributes?: Attributes;
}
/**
 * 
 * @export
 * @interface UserCreateName
 */
export interface UserCreateName {
    /**
     * The first name of the user.
     * @type {string}
     * @memberof UserCreateName
     */
    firstName?: string;
    /**
     * The middle name(s) of the user.
     * @type {string}
     * @memberof UserCreateName
     */
    middleName?: string;
    /**
     * The last name of the user.
     * @type {string}
     * @memberof UserCreateName
     */
    lastName?: string;
}
/**
 * 
 * @export
 * @interface UserCreateResponse
 */
export interface UserCreateResponse {
    /**
     * 
     * @type {string}
     * @memberof UserCreateResponse
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateResponse
     */
    userId?: string;
    /**
     * The id for the created email.
     * @type {string}
     * @memberof UserCreateResponse
     */
    emailId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCreateResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface UserDeleteEmailResponse
 */
export interface UserDeleteEmailResponse {
    /**
     * 
     * @type {string}
     * @memberof UserDeleteEmailResponse
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDeleteEmailResponse
     */
    userId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDeleteEmailResponse
     */
    emailId?: string;
}
/**
 * 
 * @export
 * @interface UserDeleteResponse
 */
export interface UserDeleteResponse {
    /**
     * 
     * @type {string}
     * @memberof UserDeleteResponse
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserDeleteResponse
     */
    userId?: string;
}
/**
 * 
 * @export
 * @interface UserGetInvitedResponse
 */
export interface UserGetInvitedResponse {
    /**
     * 
     * @type {string}
     * @memberof UserGetInvitedResponse
     */
    requestId?: string;
    /**
     * 
     * @type {Array<UserGetInvitedResponseUsers>}
     * @memberof UserGetInvitedResponse
     */
    users?: Array<UserGetInvitedResponseUsers>;
}
/**
 * 
 * @export
 * @interface UserGetInvitedResponseUsers
 */
export interface UserGetInvitedResponseUsers {
    /**
     * 
     * @type {string}
     * @memberof UserGetInvitedResponseUsers
     */
    userId?: string;
    /**
     * 
     * @type {UserGetResponseName}
     * @memberof UserGetInvitedResponseUsers
     */
    name?: UserGetResponseName;
    /**
     * 
     * @type {Array<UserUpdateResponseEmails>}
     * @memberof UserGetInvitedResponseUsers
     */
    emails?: Array<UserUpdateResponseEmails>;
    /**
     * 
     * @type {string}
     * @memberof UserGetInvitedResponseUsers
     */
    status?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetInvitedResponseUsers
     */
    invitedAt?: string;
}
/**
 * 
 * @export
 * @interface UserGetResponse
 */
export interface UserGetResponse {
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    userId?: string;
    /**
     * 
     * @type {UserGetResponseName}
     * @memberof UserGetResponse
     */
    name?: UserGetResponseName;
    /**
     * 
     * @type {Array<UserUpdateResponseEmails>}
     * @memberof UserGetResponse
     */
    emails?: Array<UserUpdateResponseEmails>;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponse
     */
    status?: string;
}
/**
 * 
 * @export
 * @interface UserGetResponseName
 */
export interface UserGetResponseName {
    /**
     * 
     * @type {string}
     * @memberof UserGetResponseName
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponseName
     */
    middleName?: string;
    /**
     * 
     * @type {string}
     * @memberof UserGetResponseName
     */
    lastName?: string;
}
/**
 * 
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {UserUpdateName}
     * @memberof UserUpdate
     */
    name?: UserUpdateName;
    /**
     * Multiple emails can exist for one user. Add additional emails via this endpoint. To delete an email, use the delete endpoint.
     * @type {Array<UserUpdateEmails>}
     * @memberof UserUpdate
     */
    emails?: Array<UserUpdateEmails>;
    /**
     * 
     * @type {Attributes}
     * @memberof UserUpdate
     */
    attributes?: Attributes;
}
/**
 * 
 * @export
 * @interface UserUpdateEmails
 */
export interface UserUpdateEmails {
    /**
     * An email for the user.
     * @type {string}
     * @memberof UserUpdateEmails
     */
    email?: string;
}
/**
 * If at least one name field is passed, all name fields will be updated.
 * @export
 * @interface UserUpdateName
 */
export interface UserUpdateName {
    /**
     * The first name of the user. Replaces an existing first name, if it exists.
     * @type {string}
     * @memberof UserUpdateName
     */
    firstName?: string;
    /**
     * The middle name(s) of the user. Replaces an existing middle name, if it exists.
     * @type {string}
     * @memberof UserUpdateName
     */
    middleName?: string;
    /**
     * The last name of the user. Replaces an existing last name, if it exists.
     * @type {string}
     * @memberof UserUpdateName
     */
    lastName?: string;
}
/**
 * 
 * @export
 * @interface UserUpdateResponse
 */
export interface UserUpdateResponse {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateResponse
     */
    requestId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateResponse
     */
    userId?: string;
    /**
     * 
     * @type {Array<UserUpdateResponseEmails>}
     * @memberof UserUpdateResponse
     */
    emails?: Array<UserUpdateResponseEmails>;
}
/**
 * 
 * @export
 * @interface UserUpdateResponseEmails
 */
export interface UserUpdateResponseEmails {
    /**
     * 
     * @type {string}
     * @memberof UserUpdateResponseEmails
     */
    emailId?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdateResponseEmails
     */
    email?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdateResponseEmails
     */
    verified?: boolean;
}
/**
 * MagicLinksApi - fetch parameter creator
 * @export
 */
export const MagicLinksApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Send an invite magic link to the user based on their email. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Invite by email with magic link
         * @param {MagicLinkInviteByEmail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteByEmail(body: MagicLinkInviteByEmail, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling inviteByEmail.');
            }
            const localVarPath = `/magic_links/invite_by_email`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MagicLinkInviteByEmail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send either a login or sign up magic link to the user based on if the email is associated with a user already. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Login or sign up with magic link
         * @param {MagicLinkLoginOrCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginOrCreateWithMagicLink(body: MagicLinkLoginOrCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loginOrCreateWithMagicLink.');
            }
            const localVarPath = `/magic_links/login_or_create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MagicLinkLoginOrCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send either a login or invite magic link to the user based on if the email is associated with a user already. If an invite is sent a user is not created until the token is authenticated. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Login or invite with magic link
         * @param {MagicLinkLoginOrInvite} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginOrInviteByMagicLink(body: MagicLinkLoginOrInvite, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling loginOrInviteByMagicLink.');
            }
            const localVarPath = `/magic_links/login_or_invite`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MagicLinkLoginOrInvite" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate a user given a magic link. This endpoint verifies that the link is valid, hasn't expired, and any optional security settings such as ip match or user agent match are satisfied.
         * @summary Authenticate magic link
         * @param {MagicLinkAuthenticate} body Magic link object
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateMagicLink(body: MagicLinkAuthenticate, token: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling authenticateMagicLink.');
            }
            // verify required parameter 'token' is not null or undefined
            if (token === null || token === undefined) {
                throw new RequiredError('token','Required parameter token was null or undefined when calling authenticateMagicLink.');
            }
            const localVarPath = `/magic_links/{token}/authenticate`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MagicLinkAuthenticate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revokes a pending invite based on the email provided.
         * @summary Revoke a pending invite
         * @param {MagicLinkRevokeInviteByEmail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeInviteByEmail(body: MagicLinkRevokeInviteByEmail, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling revokeInviteByEmail.');
            }
            const localVarPath = `/magic_links/revoke_invite`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MagicLinkRevokeInviteByEmail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a magic link to the user. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Send magic link by email
         * @param {MagicLinkSendByEmail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailMagicLink(body: MagicLinkSendByEmail, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendEmailMagicLink.');
            }
            const localVarPath = `/magic_links/send_by_email`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MagicLinkSendByEmail" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Send a magic link to the user. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Send magic link
         * @param {MagicLinkSend} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMagicLink(body: MagicLinkSend, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling sendMagicLink.');
            }
            const localVarPath = `/magic_links/send`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"MagicLinkSend" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MagicLinksApi - functional programming interface
 * @export
 */
export const MagicLinksApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Send an invite magic link to the user based on their email. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Invite by email with magic link
         * @param {MagicLinkInviteByEmail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteByEmail(body: MagicLinkInviteByEmail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MagicLinkInviteByEmailResponse> {
            const localVarFetchArgs = MagicLinksApiFetchParamCreator(configuration).inviteByEmail(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send either a login or sign up magic link to the user based on if the email is associated with a user already. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Login or sign up with magic link
         * @param {MagicLinkLoginOrCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginOrCreateWithMagicLink(body: MagicLinkLoginOrCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MagicLinkLoginOrCreateResponse> {
            const localVarFetchArgs = MagicLinksApiFetchParamCreator(configuration).loginOrCreateWithMagicLink(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send either a login or invite magic link to the user based on if the email is associated with a user already. If an invite is sent a user is not created until the token is authenticated. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Login or invite with magic link
         * @param {MagicLinkLoginOrInvite} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginOrInviteByMagicLink(body: MagicLinkLoginOrInvite, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MagicLinkLoginOrInviteResponse> {
            const localVarFetchArgs = MagicLinksApiFetchParamCreator(configuration).loginOrInviteByMagicLink(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Authenticate a user given a magic link. This endpoint verifies that the link is valid, hasn't expired, and any optional security settings such as ip match or user agent match are satisfied.
         * @summary Authenticate magic link
         * @param {MagicLinkAuthenticate} body Magic link object
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateMagicLink(body: MagicLinkAuthenticate, token: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MagicLinkAuthenticateResponse> {
            const localVarFetchArgs = MagicLinksApiFetchParamCreator(configuration).authenticateMagicLink(body, token, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Revokes a pending invite based on the email provided.
         * @summary Revoke a pending invite
         * @param {MagicLinkRevokeInviteByEmail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeInviteByEmail(body: MagicLinkRevokeInviteByEmail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MagicLinkRevokeInviteByEmailResponse> {
            const localVarFetchArgs = MagicLinksApiFetchParamCreator(configuration).revokeInviteByEmail(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send a magic link to the user. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Send magic link by email
         * @param {MagicLinkSendByEmail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailMagicLink(body: MagicLinkSendByEmail, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MagicLinkSendByEmailResponse> {
            const localVarFetchArgs = MagicLinksApiFetchParamCreator(configuration).sendEmailMagicLink(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Send a magic link to the user. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Send magic link
         * @param {MagicLinkSend} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMagicLink(body: MagicLinkSend, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<MagicLinkSendResponse> {
            const localVarFetchArgs = MagicLinksApiFetchParamCreator(configuration).sendMagicLink(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * MagicLinksApi - factory interface
 * @export
 */
export const MagicLinksApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Send an invite magic link to the user based on their email. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Invite by email with magic link
         * @param {MagicLinkInviteByEmail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        inviteByEmail(body: MagicLinkInviteByEmail, options?: any) {
            return MagicLinksApiFp(configuration).inviteByEmail(body, options)(fetch, basePath);
        },
        /**
         * Send either a login or sign up magic link to the user based on if the email is associated with a user already. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Login or sign up with magic link
         * @param {MagicLinkLoginOrCreate} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginOrCreateWithMagicLink(body: MagicLinkLoginOrCreate, options?: any) {
            return MagicLinksApiFp(configuration).loginOrCreateWithMagicLink(body, options)(fetch, basePath);
        },
        /**
         * Send either a login or invite magic link to the user based on if the email is associated with a user already. If an invite is sent a user is not created until the token is authenticated. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Login or invite with magic link
         * @param {MagicLinkLoginOrInvite} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginOrInviteByMagicLink(body: MagicLinkLoginOrInvite, options?: any) {
            return MagicLinksApiFp(configuration).loginOrInviteByMagicLink(body, options)(fetch, basePath);
        },
        /**
         * Authenticate a user given a magic link. This endpoint verifies that the link is valid, hasn't expired, and any optional security settings such as ip match or user agent match are satisfied.
         * @summary Authenticate magic link
         * @param {MagicLinkAuthenticate} body Magic link object
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authenticateMagicLink(body: MagicLinkAuthenticate, token: string, options?: any) {
            return MagicLinksApiFp(configuration).authenticateMagicLink(body, token, options)(fetch, basePath);
        },
        /**
         * Revokes a pending invite based on the email provided.
         * @summary Revoke a pending invite
         * @param {MagicLinkRevokeInviteByEmail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeInviteByEmail(body: MagicLinkRevokeInviteByEmail, options?: any) {
            return MagicLinksApiFp(configuration).revokeInviteByEmail(body, options)(fetch, basePath);
        },
        /**
         * Send a magic link to the user. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Send magic link by email
         * @param {MagicLinkSendByEmail} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendEmailMagicLink(body: MagicLinkSendByEmail, options?: any) {
            return MagicLinksApiFp(configuration).sendEmailMagicLink(body, options)(fetch, basePath);
        },
        /**
         * Send a magic link to the user. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
         * @summary Send magic link
         * @param {MagicLinkSend} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMagicLink(body: MagicLinkSend, options?: any) {
            return MagicLinksApiFp(configuration).sendMagicLink(body, options)(fetch, basePath);
        },
    };
};

/**
 * MagicLinksApi - object-oriented interface
 * @export
 * @class MagicLinksApi
 * @extends {BaseAPI}
 */
export class MagicLinksApi extends BaseAPI {
    /**
     * Send an invite magic link to the user based on their email. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
     * @summary Invite by email with magic link
     * @param {MagicLinkInviteByEmail} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicLinksApi
     */
    public inviteByEmail(body: MagicLinkInviteByEmail, options?: any) {
        return MagicLinksApiFp(this.configuration).inviteByEmail(body, options)(this.fetch, this.basePath);
    }

    /**
     * Send either a login or sign up magic link to the user based on if the email is associated with a user already. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
     * @summary Login or sign up with magic link
     * @param {MagicLinkLoginOrCreate} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicLinksApi
     */
    public loginOrCreateWithMagicLink(body: MagicLinkLoginOrCreate, options?: any) {
        return MagicLinksApiFp(this.configuration).loginOrCreateWithMagicLink(body, options)(this.fetch, this.basePath);
    }

    /**
     * Send either a login or invite magic link to the user based on if the email is associated with a user already. If an invite is sent a user is not created until the token is authenticated. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
     * @summary Login or invite with magic link
     * @param {MagicLinkLoginOrInvite} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicLinksApi
     */
    public loginOrInviteByMagicLink(body: MagicLinkLoginOrInvite, options?: any) {
        return MagicLinksApiFp(this.configuration).loginOrInviteByMagicLink(body, options)(this.fetch, this.basePath);
    }

    /**
     * Authenticate a user given a magic link. This endpoint verifies that the link is valid, hasn't expired, and any optional security settings such as ip match or user agent match are satisfied.
     * @summary Authenticate magic link
     * @param {MagicLinkAuthenticate} body Magic link object
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicLinksApi
     */
    public authenticateMagicLink(body: MagicLinkAuthenticate, token: string, options?: any) {
        return MagicLinksApiFp(this.configuration).authenticateMagicLink(body, token, options)(this.fetch, this.basePath);
    }

    /**
     * Revokes a pending invite based on the email provided.
     * @summary Revoke a pending invite
     * @param {MagicLinkRevokeInviteByEmail} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicLinksApi
     */
    public revokeInviteByEmail(body: MagicLinkRevokeInviteByEmail, options?: any) {
        return MagicLinksApiFp(this.configuration).revokeInviteByEmail(body, options)(this.fetch, this.basePath);
    }

    /**
     * Send a magic link to the user. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
     * @summary Send magic link by email
     * @param {MagicLinkSendByEmail} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicLinksApi
     */
    public sendEmailMagicLink(body: MagicLinkSendByEmail, options?: any) {
        return MagicLinksApiFp(this.configuration).sendEmailMagicLink(body, options)(this.fetch, this.basePath);
    }

    /**
     * Send a magic link to the user. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it's clicked from.
     * @summary Send magic link
     * @param {MagicLinkSend} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MagicLinksApi
     */
    public sendMagicLink(body: MagicLinkSend, options?: any) {
        return MagicLinksApiFp(this.configuration).sendMagicLink(body, options)(this.fetch, this.basePath);
    }

}
/**
 * UsersApi - fetch parameter creator
 * @export
 */
export const UsersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a user to Stytch. A user_id is returned in the response that can then be used to perform other operations within Stytch.
         * @summary Create user
         * @param {UserCreate} body Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: UserCreate, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUser.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserCreate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove a user from Stytch.
         * @summary Delete user
         * @param {string} userId The user_id to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove an email from a given user.
         * @summary Delete user email
         * @param {string} userId The user_id to delete an email from.
         * @param {string} email The email to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserEmail(userId: string, email: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling deleteUserEmail.');
            }
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling deleteUserEmail.');
            }
            const localVarPath = `/users/{user_id}/emails/{email}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch all outstanding invited users to see what their various attributes are.
         * @summary Get invited users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitedUsers(options: any = {}): FetchArgs {
            const localVarPath = `/users/invites`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch a given user to see what their various attributes are.
         * @summary Get user
         * @param {string} userId The user_id for the user to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByID(userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling getUserByID.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user's attributes. For example, you can add additional emails or change the user's primary email.
         * @summary Update user
         * @param {UserUpdate} body Updated user object
         * @param {string} userId The user_id to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UserUpdate, userId: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUser.');
            }
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            // http basic authentication required
            if (configuration && (configuration.projectId || configuration.secret)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.projectId + ":" + configuration.secret);
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"UserUpdate" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Add a user to Stytch. A user_id is returned in the response that can then be used to perform other operations within Stytch.
         * @summary Create user
         * @param {UserCreate} body Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: UserCreate, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserCreateResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).createUser(body, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove a user from Stytch.
         * @summary Delete user
         * @param {string} userId The user_id to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDeleteResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUser(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Remove an email from a given user.
         * @summary Delete user email
         * @param {string} userId The user_id to delete an email from.
         * @param {string} email The email to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserEmail(userId: string, email: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserDeleteEmailResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).deleteUserEmail(userId, email, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch all outstanding invited users to see what their various attributes are.
         * @summary Get invited users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitedUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserGetInvitedResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getInvitedUsers(options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Fetch a given user to see what their various attributes are.
         * @summary Get user
         * @param {string} userId The user_id for the user to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByID(userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserGetResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).getUserByID(userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Update a user's attributes. For example, you can add additional emails or change the user's primary email.
         * @summary Update user
         * @param {UserUpdate} body Updated user object
         * @param {string} userId The user_id to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UserUpdate, userId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<UserUpdateResponse> {
            const localVarFetchArgs = UsersApiFetchParamCreator(configuration).updateUser(body, userId, options);
            return (fetch: FetchAPI = portableFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Add a user to Stytch. A user_id is returned in the response that can then be used to perform other operations within Stytch.
         * @summary Create user
         * @param {UserCreate} body Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: UserCreate, options?: any) {
            return UsersApiFp(configuration).createUser(body, options)(fetch, basePath);
        },
        /**
         * Remove a user from Stytch.
         * @summary Delete user
         * @param {string} userId The user_id to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: any) {
            return UsersApiFp(configuration).deleteUser(userId, options)(fetch, basePath);
        },
        /**
         * Remove an email from a given user.
         * @summary Delete user email
         * @param {string} userId The user_id to delete an email from.
         * @param {string} email The email to be deleted.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserEmail(userId: string, email: string, options?: any) {
            return UsersApiFp(configuration).deleteUserEmail(userId, email, options)(fetch, basePath);
        },
        /**
         * Fetch all outstanding invited users to see what their various attributes are.
         * @summary Get invited users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvitedUsers(options?: any) {
            return UsersApiFp(configuration).getInvitedUsers(options)(fetch, basePath);
        },
        /**
         * Fetch a given user to see what their various attributes are.
         * @summary Get user
         * @param {string} userId The user_id for the user to fetch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByID(userId: string, options?: any) {
            return UsersApiFp(configuration).getUserByID(userId, options)(fetch, basePath);
        },
        /**
         * Update a user's attributes. For example, you can add additional emails or change the user's primary email.
         * @summary Update user
         * @param {UserUpdate} body Updated user object
         * @param {string} userId The user_id to update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: UserUpdate, userId: string, options?: any) {
            return UsersApiFp(configuration).updateUser(body, userId, options)(fetch, basePath);
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Add a user to Stytch. A user_id is returned in the response that can then be used to perform other operations within Stytch.
     * @summary Create user
     * @param {UserCreate} body Created user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public createUser(body: UserCreate, options?: any) {
        return UsersApiFp(this.configuration).createUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * Remove a user from Stytch.
     * @summary Delete user
     * @param {string} userId The user_id to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUser(userId: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUser(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Remove an email from a given user.
     * @summary Delete user email
     * @param {string} userId The user_id to delete an email from.
     * @param {string} email The email to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public deleteUserEmail(userId: string, email: string, options?: any) {
        return UsersApiFp(this.configuration).deleteUserEmail(userId, email, options)(this.fetch, this.basePath);
    }

    /**
     * Fetch all outstanding invited users to see what their various attributes are.
     * @summary Get invited users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getInvitedUsers(options?: any) {
        return UsersApiFp(this.configuration).getInvitedUsers(options)(this.fetch, this.basePath);
    }

    /**
     * Fetch a given user to see what their various attributes are.
     * @summary Get user
     * @param {string} userId The user_id for the user to fetch.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public getUserByID(userId: string, options?: any) {
        return UsersApiFp(this.configuration).getUserByID(userId, options)(this.fetch, this.basePath);
    }

    /**
     * Update a user's attributes. For example, you can add additional emails or change the user's primary email.
     * @summary Update user
     * @param {UserUpdate} body Updated user object
     * @param {string} userId The user_id to update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public updateUser(body: UserUpdate, userId: string, options?: any) {
        return UsersApiFp(this.configuration).updateUser(body, userId, options)(this.fetch, this.basePath);
    }

}
