/**
 * Stytch
 * This is the Stytch api.  You can find out more about Stytch at  [stytch.com](https://stytch.com). 
 *
 * OpenAPI spec version: v1
 * Contact: hello@stytch.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *//* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ErrorResponse } from '../model/errorResponse';
import { 
    MagicLinkAuthenticate,
    MagicLinkAuthenticateResponse,
    MagicLinkInviteByEmail,
    MagicLinkInviteByEmailResponse,
    MagicLinkLoginOrCreate,
    MagicLinkLoginOrCreateResponse,
    MagicLinkLoginOrInvite,
    MagicLinkLoginOrInviteResponse,
    MagicLinkRevokeInviteByEmail,
    MagicLinkRevokeInviteByEmailResponse,
    MagicLinkSend,
    MagicLinkSendByEmail,
    MagicLinkSendByEmailResponse,
    MagicLinkSendResponse,

} from '../model/magicLinks';

import { Configuration }                                     from '../configuration';


@Injectable()
export class MagicLinks {

    protected basePath = 'https://test.stytch.com/v1';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.environment == 'TEST' ? 'https://test.stytch.com/v1' : 'https://api.stytch.com/v1';
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * Invite by email with magic link
     * Send an invite magic link to the user based on their email. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it&#x27;s clicked from.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public inviteByEmail(body: MagicLinkInviteByEmail, observe?: 'body', reportProgress?: boolean): Observable<MagicLinkInviteByEmailResponse>;
    public inviteByEmail(body: MagicLinkInviteByEmail, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MagicLinkInviteByEmailResponse>>;
    public inviteByEmail(body: MagicLinkInviteByEmail, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MagicLinkInviteByEmailResponse>>;
    public inviteByEmail(body: MagicLinkInviteByEmail, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling inviteByEmail.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyAuth) required
        if (this.configuration.projectId || this.configuration.secret) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.projectId + ':' + this.configuration.secret));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<MagicLinkInviteByEmailResponse>('post',`${this.basePath}/magic_links/invite_by_email`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Login or sign up with magic link
     * Send either a login or sign up magic link to the user based on if the email is associated with a user already. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it&#x27;s clicked from.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loginOrCreateWithMagicLink(body: MagicLinkLoginOrCreate, observe?: 'body', reportProgress?: boolean): Observable<MagicLinkLoginOrCreateResponse>;
    public loginOrCreateWithMagicLink(body: MagicLinkLoginOrCreate, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MagicLinkLoginOrCreateResponse>>;
    public loginOrCreateWithMagicLink(body: MagicLinkLoginOrCreate, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MagicLinkLoginOrCreateResponse>>;
    public loginOrCreateWithMagicLink(body: MagicLinkLoginOrCreate, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling loginOrCreateWithMagicLink.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyAuth) required
        if (this.configuration.projectId || this.configuration.secret) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.projectId + ':' + this.configuration.secret));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<MagicLinkLoginOrCreateResponse>('post',`${this.basePath}/magic_links/login_or_create`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Login or invite with magic link
     * Send either a login or invite magic link to the user based on if the email is associated with a user already. If an invite is sent a user is not created until the token is authenticated. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it&#x27;s clicked from.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public loginOrInviteByMagicLink(body: MagicLinkLoginOrInvite, observe?: 'body', reportProgress?: boolean): Observable<MagicLinkLoginOrInviteResponse>;
    public loginOrInviteByMagicLink(body: MagicLinkLoginOrInvite, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MagicLinkLoginOrInviteResponse>>;
    public loginOrInviteByMagicLink(body: MagicLinkLoginOrInvite, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MagicLinkLoginOrInviteResponse>>;
    public loginOrInviteByMagicLink(body: MagicLinkLoginOrInvite, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling loginOrInviteByMagicLink.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyAuth) required
        if (this.configuration.projectId || this.configuration.secret) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.projectId + ':' + this.configuration.secret));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<MagicLinkLoginOrInviteResponse>('post',`${this.basePath}/magic_links/login_or_invite`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Authenticate magic link
     * Authenticate a user given a magic link. This endpoint verifies that the link is valid, hasn&#x27;t expired, and any optional security settings such as ip match or user agent match are satisfied.
     * @param body Magic link object
     * @param token 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public postUserMagicLinkAuthenticate(body: MagicLinkAuthenticate, token: string, observe?: 'body', reportProgress?: boolean): Observable<MagicLinkAuthenticateResponse>;
    public postUserMagicLinkAuthenticate(body: MagicLinkAuthenticate, token: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MagicLinkAuthenticateResponse>>;
    public postUserMagicLinkAuthenticate(body: MagicLinkAuthenticate, token: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MagicLinkAuthenticateResponse>>;
    public postUserMagicLinkAuthenticate(body: MagicLinkAuthenticate, token: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling postUserMagicLinkAuthenticate.');
        }

        if (token === null || token === undefined) {
            throw new Error('Required parameter token was null or undefined when calling postUserMagicLinkAuthenticate.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyAuth) required
        if (this.configuration.projectId || this.configuration.secret) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.projectId + ':' + this.configuration.secret));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<MagicLinkAuthenticateResponse>('post',`${this.basePath}/magic_links/${encodeURIComponent(String(token))}/authenticate`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Revoke a pending invite
     * Revokes a pending invite based on the email provided.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public revokeInviteByEmail(body: MagicLinkRevokeInviteByEmail, observe?: 'body', reportProgress?: boolean): Observable<MagicLinkRevokeInviteByEmailResponse>;
    public revokeInviteByEmail(body: MagicLinkRevokeInviteByEmail, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MagicLinkRevokeInviteByEmailResponse>>;
    public revokeInviteByEmail(body: MagicLinkRevokeInviteByEmail, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MagicLinkRevokeInviteByEmailResponse>>;
    public revokeInviteByEmail(body: MagicLinkRevokeInviteByEmail, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling revokeInviteByEmail.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyAuth) required
        if (this.configuration.projectId || this.configuration.secret) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.projectId + ':' + this.configuration.secret));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<MagicLinkRevokeInviteByEmailResponse>('post',`${this.basePath}/magic_links/revoke_invite`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send magic link by email
     * Send a magic link to the user. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it&#x27;s clicked from.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendEmailMagicLink(body: MagicLinkSendByEmail, observe?: 'body', reportProgress?: boolean): Observable<MagicLinkSendByEmailResponse>;
    public sendEmailMagicLink(body: MagicLinkSendByEmail, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MagicLinkSendByEmailResponse>>;
    public sendEmailMagicLink(body: MagicLinkSendByEmail, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MagicLinkSendByEmailResponse>>;
    public sendEmailMagicLink(body: MagicLinkSendByEmail, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling sendEmailMagicLink.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyAuth) required
        if (this.configuration.projectId || this.configuration.secret) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.projectId + ':' + this.configuration.secret));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<MagicLinkSendByEmailResponse>('post',`${this.basePath}/magic_links/send_by_email`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send magic link
     * Send a magic link to the user. You can optionally include additional security measures such as requiring the ip address the link is requested from match the one it&#x27;s clicked from.
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public sendMagicLink(body: MagicLinkSend, observe?: 'body', reportProgress?: boolean): Observable<MagicLinkSendResponse>;
    public sendMagicLink(body: MagicLinkSend, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<MagicLinkSendResponse>>;
    public sendMagicLink(body: MagicLinkSend, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<MagicLinkSendResponse>>;
    public sendMagicLink(body: MagicLinkSend, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (body === null || body === undefined) {
            throw new Error('Required parameter body was null or undefined when calling sendMagicLink.');
        }

        let headers = this.defaultHeaders;

        // authentication (apiKeyAuth) required
        if (this.configuration.projectId || this.configuration.secret) {
            headers = headers.set('Authorization', 'Basic ' + btoa(this.configuration.projectId + ':' + this.configuration.secret));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.request<MagicLinkSendResponse>('post',`${this.basePath}/magic_links/send`,
            {
                body: body,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
