"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sessions = void 0;
var _method_options = require("../shared/method_options");
var _shared = require("../shared");
var _sessions = require("../shared/sessions");
var _rbac_local = require("./rbac_local");
// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

// Request type for `sessions.attest`.

// Response type for `sessions.attest`.

// Request type for `sessions.authenticate`.

// Response type for `sessions.authenticate`.

// Request type for `sessions.exchangeAccessToken`.

// Response type for `sessions.exchangeAccessToken`.

// Request type for `sessions.exchange`.

// Response type for `sessions.exchange`.

// Request type for `sessions.getJWKS`.

// Response type for `sessions.getJWKS`.

// Request type for `sessions.get`.

// Response type for `sessions.get`.

// Request type for `sessions.migrate`.

// Response type for `sessions.migrate`.

// Request type for `sessions.revoke`.

// Response type for `sessions.revoke`.

// MANUAL(authenticateJwt)(TYPES)

// Request type for `sessions.authenticateJwt`

// Request type for `sessions.authenticateJwtLocal`

// ENDMANUAL(authenticateJwt)

class Sessions {
  constructor(fetchConfig, jwtConfig, policyCache) {
    this.fetchConfig = fetchConfig;
    this.jwksClient = jwtConfig.jwks;
    this.jwtOptions = {
      audience: jwtConfig.projectID,
      issuer: jwtConfig.issuers,
      typ: "JWT"
    };
    this.policyCache = policyCache;
  }

  /**
   * Retrieves all active Sessions for a Member.
   * @param params {@link B2BSessionsGetRequest}
   * @returns {@link B2BSessionsGetResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  get(params) {
    const headers = {};
    return (0, _shared.request)(this.fetchConfig, {
      method: "GET",
      url: `/v1/b2b/sessions`,
      headers,
      params: {
        ...params
      }
    });
  }

  /**
   * Authenticates a Session and updates its lifetime by the specified `session_duration_minutes`. If the
   * `session_duration_minutes` is not specified, a Session will not be extended. This endpoint requires
   * either a `session_jwt` or `session_token` be included in the request. It will return an error if both
   * are present.
   *
   * You may provide a JWT that needs to be refreshed and is expired according to its `exp` claim. A new JWT
   * will be returned if both the signature and the underlying Session are still valid. See our
   * [How to use Stytch Session JWTs](https://stytch.com/docs/b2b/guides/sessions/resources/using-jwts) guide
   * for more information.
   *
   * If an `authorization_check` object is passed in, this method will also check if the Member is authorized
   * to perform the given action on the given Resource in the specified Organization. A Member is authorized
   * if their Member Session contains a Role, assigned
   * [explicitly or implicitly](https://stytch.com/docs/b2b/guides/rbac/role-assignment), with adequate
   * permissions.
   * In addition, the `organization_id` passed in the authorization check must match the Member's
   * Organization.
   *
   * If the Member is not authorized to perform the specified action on the specified Resource, or if the
   * `organization_id` does not match the Member's Organization, a 403 error will be thrown.
   * Otherwise, the response will contain a list of Roles that satisfied the authorization check.
   * @param data {@link B2BSessionsAuthenticateRequest}
   * @returns {@link B2BSessionsAuthenticateResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  authenticate(data) {
    const headers = {};
    return (0, _shared.request)(this.fetchConfig, {
      method: "POST",
      url: `/v1/b2b/sessions/authenticate`,
      headers,
      data
    });
  }

  /**
   * Revoke a Session and immediately invalidate all its tokens. To revoke a specific Session, pass either
   * the `member_session_id`, `session_token`, or `session_jwt`. To revoke all Sessions for a Member, pass
   * the `member_id`.
   * @param data {@link B2BSessionsRevokeRequest}
   * @param options {@link B2BSessionsRevokeRequestOptions}
   * @returns {@link B2BSessionsRevokeResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  revoke(data, options) {
    const headers = {};
    if (options?.authorization) {
      (0, _method_options.addAuthorizationHeaders)(headers, options.authorization);
    }
    return (0, _shared.request)(this.fetchConfig, {
      method: "POST",
      url: `/v1/b2b/sessions/revoke`,
      headers,
      data
    });
  }

  /**
   * Use this endpoint to exchange a Member's existing session for another session in a different
   * Organization. This can be used to accept an invite, but not to create a new member via domain matching.
   *
   * To create a new member via email domain JIT Provisioning, use the
   * [Exchange Intermediate Session](https://stytch.com/docs/b2b/api/exchange-intermediate-session) flow
   * instead.
   *
   * If the user **has** already satisfied the authentication requirements of the Organization they are
   * trying to switch into, this API will return `member_authenticated: true` and a `session_token` and
   * `session_jwt`.
   *
   * If the user **has not** satisfied the primary or secondary authentication requirements of the
   * Organization they are attempting to switch into, this API will return `member_authenticated: false` and
   * an `intermediate_session_token`.
   *
   * If `primary_required` is set, prompt the user to fulfill the Organization's auth requirements using the
   * options returned in `primary_required.allowed_auth_methods`.
   *
   * If `primary_required` is null and `mfa_required` is set, check `mfa_required.member_options` to
   * determine if the Member has SMS OTP or TOTP set up for MFA and prompt accordingly. If the Member has SMS
   * OTP, check `mfa_required.secondary_auth_initiated` to see if the OTP has already been sent.
   *
   * Include the `intermediate_session_token` returned above when calling the `authenticate()` method that
   * the user needed to perform. Once the user has completed the authentication requirements they were
   * missing, they will be granted a full `session_token` and `session_jwt` to indicate they have
   * successfully logged into the Organization.
   *
   * The `intermediate_session_token` can also be used with the
   * [Exchange Intermediate Session endpoint](https://stytch.com/docs/b2b/api/exchange-intermediate-session)
   * or the
   * [Create Organization via Discovery endpoint](https://stytch.com/docs/b2b/api/create-organization-via-discovery) to join a different Organization or create a new one.
   * The `session_duration_minutes` and `session_custom_claims` parameters will be ignored.
   * @param data {@link B2BSessionsExchangeRequest}
   * @returns {@link B2BSessionsExchangeResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  exchange(data) {
    const headers = {};
    return (0, _shared.request)(this.fetchConfig, {
      method: "POST",
      url: `/v1/b2b/sessions/exchange`,
      headers,
      data
    });
  }

  /**
   * Use this endpoint to exchange a Connected Apps Access Token back into a Member Session for the
   * underlying Member.
   * This session can be used with the Stytch SDKs and APIs.
   *
   * The Access Token must contain the `full_access` scope (only available to First Party clients) and must
   * not be more than 5 minutes old. Access Tokens may only be exchanged a single time.
   *
   * Because the Member previously completed MFA and satisfied all Organization authentication requirements
   * at the time of the original Access Token issuance, this endpoint will never return an
   * `intermediate_session_token` or require MFA.
   * @param data {@link B2BSessionsExchangeAccessTokenRequest}
   * @returns {@link B2BSessionsExchangeAccessTokenResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  exchangeAccessToken(data) {
    const headers = {};
    return (0, _shared.request)(this.fetchConfig, {
      method: "POST",
      url: `/v1/b2b/sessions/exchange_access_token`,
      headers,
      data
    });
  }

  /**
   * Exchange an auth token issued by a trusted identity provider for a Stytch session. You must first
   * register a Trusted Auth Token profile in the Stytch dashboard
   * [here](https://stytch.com/dashboard/trusted-auth-tokens).  If a session token or session JWT is
   * provided, it will add the trusted auth token as an authentication factor to the existing session.
   * @param data {@link B2BSessionsAttestRequest}
   * @returns {@link B2BSessionsAttestResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  attest(data) {
    const headers = {};
    return (0, _shared.request)(this.fetchConfig, {
      method: "POST",
      url: `/v1/b2b/sessions/attest`,
      headers,
      data
    });
  }

  /**
   * Migrate a session from an external OIDC compliant endpoint.
   * Stytch will call the external UserInfo endpoint defined in your Stytch Project settings in the
   * [Dashboard](https://stytch.com/dashboard/migrations), and then perform a lookup using the
   * `session_token`.
   * If the response contains a valid email address, Stytch will attempt to match that email address with an
   * existing Member in your Organization and create a Stytch Session.
   * You will need to create the member before using this endpoint.
   * @param data {@link B2BSessionsMigrateRequest}
   * @returns {@link B2BSessionsMigrateResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  migrate(data) {
    const headers = {};
    return (0, _shared.request)(this.fetchConfig, {
      method: "POST",
      url: `/v1/b2b/sessions/migrate`,
      headers,
      data
    });
  }

  /**
   * Get the JSON Web Key Set (JWKS) for a project.
   *
   * Within the JWKS, the JSON Web Keys are rotated every ~6 months. Upon rotation, new JWTs will be signed
   * using the new key, and both keys will be returned by this endpoint for a period of 1 month.
   *
   * JWTs have a set lifetime of 5 minutes, so there will be a 5 minute period where some JWTs will be signed
   * by the old keys, and some JWTs will be signed by the new keys. The correct key to use for validation is
   * determined by matching the `kid` value of the JWT and key.
   *
   * If you're using one of our [backend SDKs](https://stytch.com/docs/b2b/sdks), the JSON Web Key (JWK)
   * rotation will be handled for you.
   *
   * If you're using your own JWT validation library, many have built-in support for JWK rotation, and you'll
   * just need to supply this API endpoint. If not, your application should decide which JWK to use for
   * validation by inspecting the `kid` value.
   *
   * See our
   * [How to use Stytch Session JWTs](https://stytch.com/docs/b2b/guides/sessions/resources/using-jwts) guide
   * for more information.
   * @param params {@link B2BSessionsGetJWKSRequest}
   * @returns {@link B2BSessionsGetJWKSResponse}
   * @async
   * @throws A {@link StytchError} on a non-2xx response from the Stytch API
   * @throws A {@link RequestError} when the Stytch API cannot be reached
   */
  getJWKS(params) {
    const headers = {};
    return (0, _shared.request)(this.fetchConfig, {
      method: "GET",
      url: `/v1/b2b/sessions/jwks/${encodeURIComponent(params.project_id)}`,
      headers,
      params: {}
    });
  }

  // MANUAL(authenticateJwt)(SERVICE_METHOD)
  // ADDIMPORT: import { JwtConfig, authenticateSessionJwtLocal } from "../shared/sessions";
  // ADDIMPORT: import { performAuthorizationCheck } from "./rbac_local";
  /** Parse a JWT and verify the signature, preferring local verification over remote.
   *
   * If max_token_age_seconds is set, remote verification will be forced if the JWT was issued at
   * (based on the "iat" claim) more than that many seconds ago.
   *
   * To force remote validation for all tokens, set max_token_age_seconds to zero or use the
   * authenticate method instead.
   */
  async authenticateJwt(params) {
    try {
      const member_session = await this.authenticateJwtLocal(params);
      return {
        member_session,
        session_jwt: params.session_jwt
      };
    } catch (err) {
      // JWT could not be verified locally. Check with the Stytch API.
      return this.authenticate({
        session_jwt: params.session_jwt,
        authorization_check: params.authorization_check
      });
    }
  }

  /** Parse a JWT and verify the signature locally (without calling /authenticate in the API).
   *
   * If maxTokenAge is set, this will return an error if the JWT was issued (based on the "iat"
   * claim) more than maxTokenAge seconds ago.
   *
   * If max_token_age_seconds is explicitly set to zero, all tokens will be considered too old,
   * even if they are otherwise valid.
   *
   * The value for current_date is used to compare timestamp claims ("exp", "nbf", "iat"). It
   * defaults to the current date (new Date()).
   *
   * The value for clock_tolerance_seconds is the maximum allowable difference when comparing
   * timestamps. It defaults to zero.
   */
  async authenticateJwtLocal(params) {
    const sess = await (0, _sessions.authenticateSessionJwtLocal)(this.jwksClient, this.jwtOptions, params.session_jwt, {
      clock_tolerance_seconds: params.clock_tolerance_seconds,
      max_token_age_seconds: params.max_token_age_seconds,
      current_date: params.current_date
    });
    const organizationClaim = "https://stytch.com/organization";
    const {
      [organizationClaim]: orgClaimUntyped,
      ...claims
    } = sess.custom_claims;
    const orgClaim = orgClaimUntyped;
    if (params.authorization_check) {
      const [projectPolicy, orgPolicy] = await Promise.all([this.policyCache.getPolicy(), this.policyCache.getOrgPolicy(orgClaim.organization_id)]);
      const policyRoles = Array.isArray(orgPolicy?.roles) ? projectPolicy.roles.concat(orgPolicy.roles) : projectPolicy.roles;
      (0, _rbac_local.performAuthorizationCheck)({
        policyRoles,
        subjectRoles: sess.roles,
        subjectOrgID: orgClaim.organization_id,
        authorizationCheck: params.authorization_check
      });
    }
    return {
      member_session_id: sess.session_id,
      member_id: sess.sub,
      organization_id: orgClaim.organization_id,
      authentication_factors: sess.authentication_factors,
      started_at: sess.started_at,
      last_accessed_at: sess.last_accessed_at,
      expires_at: sess.expires_at,
      custom_claims: claims,
      roles: sess.roles,
      organization_slug: orgClaim.slug
    };
  }

  // ENDMANUAL(authenticateJwt)
}
exports.Sessions = Sessions;