"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sessions = void 0;

var _sessions = require("../shared/sessions");

var _shared = require("../shared");

// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!
class Sessions {
  constructor(fetchConfig, jwtConfig) {
    this.fetchConfig = fetchConfig;
    this.jwksClient = jwtConfig.jwks;
    this.jwtOptions = {
      audience: jwtConfig.projectID,
      issuer: `stytch.com/${jwtConfig.projectID}`,
      typ: "JWT"
    };
  } // Retrieves all active Sessions for a Member.


  get(params) {
    return (0, _shared.request)(this.fetchConfig, {
      method: "GET",
      url: `/v1/b2b/sessions`,
      params: { ...params
      }
    });
  }
  /**
   * Authenticates a Session and updates its lifetime by the specified `session_duration_minutes`. If the
   * `session_duration_minutes` is not specified, a Session will not be extended. This endpoint requires
   * either a `session_jwt` or `session_token` be included in the request. It will return an error if both
   * are present.
   *
   * You may provide a JWT that needs to be refreshed and is expired according to its `exp` claim. A new JWT
   * will be returned if both the signature and the underlying Session are still valid.
   */


  authenticate(data) {
    return (0, _shared.request)(this.fetchConfig, {
      method: "POST",
      url: `/v1/b2b/sessions/authenticate`,
      data
    });
  }
  /**
   * Revoke a Session and immediately invalidate all its tokens. To revoke a specific Session, pass either
   * the `member_session_id`, `session_token`, or `session_jwt`. To revoke all Sessions for a Member, pass
   * the `member_id`.
   */


  revoke(data) {
    return (0, _shared.request)(this.fetchConfig, {
      method: "POST",
      url: `/v1/b2b/sessions/revoke`,
      data
    });
  }
  /**
   * Use this endpoint to exchange a Member's existing session for another session in a different
   * Organization. This can be used to accept an invite, but not to create a new member via domain matching.
   *
   * To create a new member via domain matching, use the
   * [Exchange Intermediate Session](https://stytch.com/docs/b2b/api/exchange-intermediate-session) flow
   * instead.
   */


  exchange(data) {
    return (0, _shared.request)(this.fetchConfig, {
      method: "POST",
      url: `/v1/b2b/sessions/exchange`,
      data
    });
  } // Get the JSON Web Key Set (JWKS) for a project.


  getJWKS(params) {
    return (0, _shared.request)(this.fetchConfig, {
      method: "GET",
      url: `/v1/b2b/sessions/jwks/${params.project_id}`,
      params: {}
    });
  } // MANUAL(authenticateJwt)(SERVICE_METHOD)

  /** Parse a JWT and verify the signature, preferring local verification over remote.
   *
   * If max_token_age_seconds is set, remote verification will be forced if the JWT was issued at
   * (based on the "iat" claim) more than that many seconds ago.
   *
   * To force remote validation for all tokens, set max_token_age_seconds to zero or use the
   * authenticate method instead.
   */


  async authenticateJwt(jwt, options) {
    try {
      const member_session = await this.authenticateJwtLocal(jwt, options);
      return {
        member_session,
        session_jwt: jwt
      };
    } catch (err) {
      // JWT could not be verified locally. Check with the Stytch API.
      return this.authenticate({
        session_jwt: jwt
      });
    }
  }
  /** Parse a JWT and verify the signature locally (without calling /authenticate in the API).
   *
   * If maxTokenAge is set, this will return an error if the JWT was issued (based on the "iat"
   * claim) more than maxTokenAge seconds ago.
   *
   * If max_token_age_seconds is explicitly set to zero, all tokens will be considered too old,
   * even if they are otherwise valid.
   *
   * The value for current_date is used to compare timestamp claims ("exp", "nbf", "iat"). It
   * defaults to the current date (new Date()).
   *
   * The value for clock_tolerance_seconds is the maximum allowable difference when comparing
   * timestamps. It defaults to zero.
   */


  async authenticateJwtLocal(jwt, options) {
    const sess = await (0, _sessions.authenticateJwtLocal)(this.jwksClient, this.jwtOptions, jwt, options);
    const organizationClaim = "https://stytch.com/organization";
    const {
      [organizationClaim]: orgClaimUntyped,
      ...claims
    } = sess.custom_claims;
    const orgClaim = orgClaimUntyped; // The last_authenticated_at field from local authentication is still a string.
    // Let's strongly type it now and then convert it to a Date.

    const factorRows = sess.authentication_factors;
    const typedFactors = [];
    factorRows.forEach(factor => {
      typedFactors.push({ ...factor,
        last_authenticated_at: new Date(factor.last_authenticated_at)
      });
    });
    return {
      member_session_id: sess.session_id,
      member_id: sess.sub,
      organization_id: orgClaim.organization_id,
      authentication_factors: typedFactors,
      started_at: sess.started_at,
      last_accessed_at: sess.last_accessed_at,
      expires_at: sess.expires_at,
      custom_claims: claims
    };
  } // ENDMANUAL(authenticateJwt)


}

exports.Sessions = Sessions;