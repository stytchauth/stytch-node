"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Sessions = void 0;

var _shared = require("../shared");

var _sessions = require("../shared/sessions");

// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!
class Sessions {
  constructor(fetchConfig, jwtConfig) {
    this.fetchConfig = fetchConfig;
    this.jwksClient = jwtConfig.jwks;
    this.jwtOptions = {
      audience: jwtConfig.projectID,
      issuer: `stytch.com/${jwtConfig.projectID}`,
      typ: "JWT"
    };
  }
  /**
   * List all active Sessions for a given `user_id`. All timestamps are formatted according to the RFC 3339
   * standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`.
   */


  get(params) {
    return (0, _shared.request)(this.fetchConfig, {
      method: "GET",
      url: `/v1/sessions`,
      params: { ...params
      }
    });
  }
  /**
   * Authenticate a session token and retrieve associated session data. If `session_duration_minutes` is
   * included, update the lifetime of the session to be that many minutes from now. All timestamps are
   * formatted according to the RFC 3339 standard and are expressed in UTC, e.g. `2021-12-29T12:33:09Z`. This
   * endpoint requires exactly one `session_jwt` or `session_token` as part of the request. If both are
   * included you will receive a `too_many_session_arguments` error.
   */


  authenticate(data) {
    return (0, _shared.request)(this.fetchConfig, {
      method: "POST",
      url: `/v1/sessions/authenticate`,
      data
    });
  }
  /**
   * Revoke a Session, immediately invalidating all of its session tokens. You can revoke a session in three
   * ways: using its ID, or using one of its session tokens, or one of its JWTs. This endpoint requires
   * exactly one of those to be included in the request. It will return an error if multiple are present.
   */


  revoke(data) {
    return (0, _shared.request)(this.fetchConfig, {
      method: "POST",
      url: `/v1/sessions/revoke`,
      data
    });
  } // Get the JSON Web Key Set (JWKS) for a Stytch Project.


  getJWKS(params) {
    return (0, _shared.request)(this.fetchConfig, {
      method: "GET",
      url: `/v1/sessions/jwks/${params.project_id}`,
      params: {}
    });
  } // MANUAL(authenticateJwt)(SERVICE_METHOD)
  // ADDIMPORT: import * as jose from "jose";
  // ADDIMPORT: import { authenticateSessionJwtLocal, JwtConfig } from "../shared/sessions";

  /** Parse a JWT and verify the signature, preferring local verification over remote.
   *
   * If max_token_age_seconds is set, remote verification will be forced if the JWT was issued at
   * (based on the "iat" claim) more than that many seconds ago.
   *
   * To force remote validation for all tokens, set max_token_age_seconds to zero or use the
   * authenticate method instead.
   */


  async authenticateJwt(jwt, options) {
    try {
      const session = await this.authenticateJwtLocal(jwt, options);
      return {
        session,
        session_jwt: jwt
      };
    } catch (err) {
      // JWT could not be verified locally. Check with the Stytch API.
      return this.authenticate({
        session_jwt: jwt
      });
    }
  }
  /** Parse a JWT and verify the signature locally (without calling /authenticate in the API).
   *
   * If maxTokenAge is set, this will return an error if the JWT was issued (based on the "iat"
   * claim) more than maxTokenAge seconds ago.
   *
   * If max_token_age_seconds is explicitly set to zero, all tokens will be considered too old,
   * even if they are otherwise valid.
   *
   * The value for current_date is used to compare timestamp claims ("exp", "nbf", "iat"). It
   * defaults to the current date (new Date()).
   *
   * The value for clock_tolerance_seconds is the maximum allowable difference when comparing
   * timestamps. It defaults to zero.
   */


  async authenticateJwtLocal(jwt, options) {
    const sess = await (0, _sessions.authenticateSessionJwtLocal)(this.jwksClient, this.jwtOptions, jwt, options); // The last_authenticated_at field from local authentication is still a string.
    // Let's strongly type it now and then convert it to a Date.

    const factorRows = sess.authentication_factors;
    const typedFactors = [];
    factorRows.forEach(factor => {
      typedFactors.push({ ...factor,
        last_authenticated_at: new Date(factor.last_authenticated_at)
      });
    });
    return {
      session_id: sess.session_id,
      attributes: sess.attributes,
      authentication_factors: typedFactors,
      user_id: sess.sub,
      started_at: sess.started_at,
      last_accessed_at: sess.last_accessed_at,
      expires_at: sess.expires_at,
      custom_claims: sess.custom_claims
    };
  } // ENDMANUAL(authenticateJwt)


}

exports.Sessions = Sessions;