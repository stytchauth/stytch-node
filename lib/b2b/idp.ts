// !!!
// WARNING: This file is autogenerated
// Only modify code within MANUAL() sections
// or your changes may be overwritten later!
// !!!

import * as jose from "jose";
import {} from "../shared/method_options";
import { fetchConfig } from "../shared";
import { OAuth } from "./idp_oauth";
import { PolicyCache } from "./rbac_local";

import { AuthorizationCheck } from "./sessions";
import { ClientError } from "../shared/errors";
import { JwtConfig } from "../shared/sessions";
import { performScopeAuthorizationCheck } from "./rbac_local";
import { request } from "../shared";

export interface B2BIDPScopeResult {
  // The name of the scope.
  scope: string;
  // A human-readable description of the scope, taken from the RBAC Policy.
  description: string;
  /**
   * Indicates whether the scope can be granted. Users can only grant scopes if they have the required
   * permissions.
   */
  is_grantable: boolean;
}

// MANUAL(IntrospectToken)(TYPES)

interface OrganizationClaim {
  organization_id: string;
  slug: string;
}

export interface B2BIntrospectTokenRequest {
  token: string;
  client_id: string;
  client_secret?: string;
  token_type_hint?: string;
}

interface IntrospectTokenInactiveResponse {
  active: false;
  request_id: string;
  status_code: number;
}

interface IntrospectTokenActiveResponse {
  active: true;
  request_id: string;
  status_code: number;
  sub?: string;
  scope?: string;
  aud?: string[];
  exp?: number;
  iat?: number;
  iss?: string;
  nbf?: number;
  client_id?: string;
  token_type?: string;
  "https://stytch.com/organization"?: Record<string, string>;
}

export type B2BIntrospectTokenResponse =
  | IntrospectTokenActiveResponse
  | IntrospectTokenInactiveResponse;

export interface B2BIntrospectTokenClaims {
  subject: string;
  scope: string;
  custom_claims: Record<string, any>; // eslint-disable-line @typescript-eslint/no-explicit-any
  audience: string | string[];
  expires_at: number;
  issued_at: number;
  issuer: string;
  not_before: number;
  token_type: string;
  organization: OrganizationClaim;
}

// ENDMANUAL(IntrospectToken)

export class IDP {
  private fetchConfig: fetchConfig;
  private jwksClient: jose.JWTVerifyGetKey;
  private jwtOptions: jose.JWTVerifyOptions;
  private policyCache: PolicyCache;
  oauth: OAuth;

  constructor(
    fetchConfig: fetchConfig,
    jwtConfig: JwtConfig,
    policyCache: PolicyCache
  ) {
    this.fetchConfig = fetchConfig;
    this.oauth = new OAuth(this.fetchConfig);

    this.jwksClient = jwtConfig.jwks;
    this.jwtOptions = {
      audience: jwtConfig.projectID,
      issuer: jwtConfig.issuers,
      typ: "JWT",
    };
    this.policyCache = policyCache;
  }

  // MANUAL(introspectTokenNetwork)(SERVICE_METHOD)
  // ADDIMPORT: import { JwtConfig } from "../shared/sessions";
  // ADDIMPORT: import { AuthorizationCheck } from "./sessions";
  // ADDIMPORT: import { request } from "../shared";
  // ADDIMPORT: import { ClientError } from "../shared/errors";
  // ADDIMPORT: import { performScopeAuthorizationCheck } from "./rbac_local";
  async introspectTokenNetwork(
    data: B2BIntrospectTokenRequest,
    options?: {
      authorization_check?: AuthorizationCheck;
    }
  ): Promise<B2BIntrospectTokenClaims> {
    const fetchConfig: fetchConfig = {
      ...this.fetchConfig,
      headers: {
        ["User-Agent"]: this.fetchConfig.headers["User-Agent"],
        "Content-Type": "application/x-www-form-urlencoded",
      },
    };

    const params: Record<string, string> = {
      token: data.token,
      client_id: data.client_id,
    };

    if (data.client_secret && data.client_secret.length > 0) {
      params.client_secret = data.client_secret;
    }

    if (data.token_type_hint && data.token_type_hint.length > 0) {
      params.token_type_hint = data.token_type_hint;
    }

    let response;
    try {
      response = await request<B2BIntrospectTokenResponse>(fetchConfig, {
        method: "POST",
        url: `/v1/public/${this.jwtOptions.audience}/oauth2/introspect`,
        dataRaw: new URLSearchParams(params),
      });
    } catch (err) {
      throw new ClientError("token_invalid", "Could not introspect token", err);
    }
    if (!response.active) {
      throw new ClientError("token_invalid", "Token was not active", null);
    }
    const {
      /* eslint-disable @typescript-eslint/no-unused-vars */
      aud: _aud,
      exp: _exp,
      iat: _iat,
      iss: _iss,
      nbf: _nbf,
      sub: _sub,
      status_code: _status_code,
      scope: _scope,
      active: _active,
      request_id: _request_id,
      token_type: _token_type,
      client_id: _client_id,
      "https://stytch.com/organization": _organization_claim,
      /* eslint-enable @typescript-eslint/no-unused-vars */
      ...customClaims
    } = response;

    if (options?.authorization_check) {
      const policy = await this.policyCache.getPolicy();
      const organization_id = (_organization_claim as Record<string, string>)[
        "organization_id"
      ];
      performScopeAuthorizationCheck({
        policy,
        subjectOrgID: organization_id,
        tokenScopes: (_scope as string).trim().split(" "),
        authorizationCheck: options.authorization_check,
      });
    }

    const organization: OrganizationClaim = {
      organization_id: (_organization_claim as Record<string, string>)
        .organization_id,
      slug: (_organization_claim as Record<string, string>).slug,
    };

    return {
      subject: _sub as string,
      scope: _scope as string,
      audience: _aud as string[],
      expires_at: _exp as number,
      issued_at: _iat as number,
      issuer: _iss as string,
      not_before: _nbf as number,
      token_type: _token_type as string,
      organization,
      custom_claims: customClaims,
    };
  }

  async introspectTokenLocal(
    tokenJWT: string,
    options?: {
      clock_tolerance_seconds?: number;
      current_date?: Date;
      authorization_check?: AuthorizationCheck;
    }
  ): Promise<B2BIntrospectTokenClaims> {
    const now = options?.current_date || new Date();
    let payload;
    try {
      const token = await jose.jwtVerify(tokenJWT, this.jwksClient, {
        ...this.jwtOptions,
        clockTolerance: options?.clock_tolerance_seconds,
        currentDate: now,
      });
      payload = token.payload;
    } catch (err) {
      throw new ClientError("jwt_invalid", "Could not verify JWT", err);
    }

    // The custom claim set is all the claims in the payload except for the standard claims and
    // the scope and token_type claims. The cleanest way to collect those seems to be naming what we want
    // to omit and using ...rest for to collect the custom claims.
    const {
      /* eslint-disable @typescript-eslint/no-unused-vars */
      aud: _aud,
      exp: _exp,
      iat: _iat,
      iss: _iss,
      jti: _jti,
      nbf: _nbf,
      sub: _sub,
      scope: _scope,
      "https://stytch.com/organization": _organization_claim,
      /* eslint-enable @typescript-eslint/no-unused-vars */
      ...custom_claims
    } = payload;

    if (options?.authorization_check) {
      const policy = await this.policyCache.getPolicy();
      performScopeAuthorizationCheck({
        policy,
        subjectOrgID: (_organization_claim as Record<string, string>)[
          "organization_id"
        ],
        tokenScopes: (_scope as string).trim().split(" "),
        authorizationCheck: options.authorization_check,
      });
    }

    const organization: OrganizationClaim = {
      organization_id: (_organization_claim as Record<string, string>)
        .organization_id,
      slug: (_organization_claim as Record<string, string>).slug,
    };

    return {
      subject: _sub as string,
      expires_at: _exp as number,
      audience: _aud as string[],
      issued_at: _iat as number,
      issuer: _iss as string,
      not_before: _nbf as number,
      scope: _scope as string,
      token_type: "access_token",
      organization,
      custom_claims,
    };
  }
  // ENDMANUAL(introspectTokenNetwork)
}
